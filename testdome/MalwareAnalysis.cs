namespace testdome;

/*
 * Your company is analyzing malware which targets numerical record files.
 * 
 * The malware uses a sliding window over the array of numbers in a file, and tries to match the following pattern:
 * |
 * | T, -, -, X, -, -, -, T
 * |
 * Where the position 'X' is compared to each position 'T'. The window is moved so 'X' passes thru all the values.
 * 
 * The malware has the following rules:
 * * If any of the 'T' positions in the pattern are bigger or equal to 'X' the malware replaces 'X' with 0.
 * * If any 'X' position in the pattern is near the left or right border and is missing a 'T' position neighbor,
 *   only the other side is considered.
 * * The malware finds all the positions first and only then sets them to 0.
 * 
 * For example, if the values in a record file are the following:
 * |
 * | new int[] { 1, 2, 0, 5, 0, 2, 4, 3, 3, 3 };  The expected values after the malware runs are:
 * | new int[] { 1, 0, 0, 5, 0, 0, 0, 3, 3, 3 };
 * |
 * In this example, number 4 was set to 0 because 5 is the bigger number.
 * 
 * Implement the Simulate function so that the malware behavior is replicated for further study.
 */

/*
 * Tests: 
 * 1. Example case.
 * 2. All Entries have different values.
 * 3. Entries close to border have a value of 0.
 * 4. Various entries.
 */

internal class MalwareAnalysis
{
    public static int[] Simulate(int[] entries)
    {
        HashSet<int> indexes = new HashSet<int>();
        int n = entries.Length;

        for (int i = 0; i < n; i++)
        {
            int startIndex = i - 3;
            int endIndex = i + 4;
            int T = 0;
            int X = entries[i];

            if (endIndex < n) T = entries[endIndex];
            if (startIndex >= 0) T = Math.Max(T, entries[startIndex]);
            if (X <= T) indexes.Add(i);
        }

        foreach (var item in indexes)
        {
            entries[item] = 0;
        }

        return entries;
    }

    public static void Simulate()
    {

        int[] records = new int[] { 1, 2, 0, 5, 0, 2, 4, 3, 3, 3 };
        var result = Simulate(records);
        Console.WriteLine(string.Join(", ", result));
    }
}

/*
internal class MalwareAnalysis
{
    public static int[] Simulate(int[] entries)
    {
        throw new NotImplementedException("Waiting to be implemented.");
    }

    public static void Simulate()
    {
        //              { 0, 1, 2, 3, 4, 5, 6, 7 }
        //              { T, -, -, X, -, -, -, T }
        //
        //     { T, -, -, X, -, -, -, T }
        //    new int[] { 1, 2, 0, 5, 0, 2, 4, 3, 3, 3 };
        //        { T, -, -, X, -, -, -, T }
        //    new int[] { 1, 2, 0, 5, 0, 2, 4, 3, 3, 3 };
        //           { T, -, -, X, -, -, -, T }
        //    new int[] { 1, 2, 0, 5, 0, 2, 4, 3, 3, 3 };
        //              { T, -, -, X, -, -, -, T }
        //    new int[] { 1, 2, 0, 5, 0, 2, 4, 3, 3, 3 };
        //                 { T, -, -, X, -, -, -, T }
        //    new int[] { 1, 2, 0, 5, 0, 2, 4, 3, 3, 3 };
        //                    { T, -, -, X, -, -, -, T }
        //    new int[] { 1, 2, 0, 5, 0, 2, 4, 3, 3, 3 };
        //                       { T, -, -, X, -, -, -, T }
        //    new int[] { 1, 2, 0, 5, 0, 2, 4, 3, 3, 3 };
        //                          { T, -, -, X, -, -, -, T }
        //    new int[] { 1, 2, 0, 5, 0, 2, 4, 3, 3, 3 };
        //                             { T, -, -, X, -, -, -, T }
        //    new int[] { 1, 2, 0, 5, 0, 2, 4, 3, 3, 3 };
        //                                { T, -, -, X, -, -, -, T }
        //    new int[] { 1, 2, 0, 5, 0, 2, 4, 3, 3, 3 };
        //
        //    new int[] { 1, 2, 0, 5, 0, 2, 4, 3, 3, 3 };
        //    new int[] { 1, 0, 0, 5, 0, 0, 0, 3, 3, 0 };


        int[] records = new int[] { 1, 2, 0, 5, 0, 2, 4, 3, 3, 3 };
        var result = Simulate(records);
        Console.WriteLine(string.Join(", ", result));
    }
}
*/